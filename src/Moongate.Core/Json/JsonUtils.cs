using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;

namespace Moongate.Core.Json;

/// <summary>
/// Utility class for JSON serialization and deserialization with support for AOT (Ahead-of-Time) compilation.
/// </summary>
public static class JsonUtils
{
    /// <summary>
    /// Default serializer options used across all serialization methods.
    /// </summary>
    public static JsonSerializerOptions DefaultSerializerOptions { get; private set; } = new();

    /// <summary>
    /// Cache for JsonTypeInfo objects, enabling AOT serialization support.
    /// </summary>
    private static readonly Dictionary<Type, JsonTypeInfo> TypeInfoCache = new();

    /// <summary>
    /// Static constructor to initialize default serializer options.
    /// </summary>
    static JsonUtils()
    {
        // Initialize default options at startup
        RebuildJsonOptions();
    }

    /// <summary>
    /// Rebuilds the default serializer options with the provided options or creates new ones with standard settings.
    /// </summary>
    /// <param name="options">Optional custom serializer options. If null, new options will be created.</param>
    public static void RebuildJsonOptions(JsonSerializerOptions? options = null)
    {
        DefaultSerializerOptions = options ?? new JsonSerializerOptions()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true,
            Converters =
            {
                new JsonStringEnumConverter(JsonNamingPolicy.CamelCase),
                new JsonStringEnumConverter(JsonNamingPolicy.CamelCase, true)
            },
        };

        // Reset cache when options are rebuilt
        TypeInfoCache.Clear();
    }

    /// <summary>
    /// Adds a type-specific JSON converter to the default serializer options.
    /// </summary>
    /// <typeparam name="T">The type for which the converter is added.</typeparam>
    /// <param name="converter">The JSON converter to add.</param>
    public static void AddTypeConverter<T>(JsonConverter<T> converter)
    {
        DefaultSerializerOptions.Converters.Add(converter);
        // Reset cache for the specific type
        if (TypeInfoCache.ContainsKey(typeof(T)))
        {
            TypeInfoCache.Remove(typeof(T));
        }
    }

    /// <summary>
    /// Adds a type info resolver to the resolver chain.
    /// </summary>
    /// <typeparam name="T">The type for which the resolver is added.</typeparam>
    /// <param name="resolver">The type info resolver to add.</param>
    public static void AddTypeChainConverter<T>(IJsonTypeInfoResolver resolver)
    {
        var typeInfoResolvers = DefaultSerializerOptions.TypeInfoResolver;
        DefaultSerializerOptions.TypeInfoResolver = JsonTypeInfoResolver.Combine(typeInfoResolvers, resolver);

        // Reset cache for the specific type
        if (TypeInfoCache.ContainsKey(typeof(T)))
        {
            TypeInfoCache.Remove(typeof(T));
        }
    }

    /// <summary>
    /// Adds a generic JSON converter to the default serializer options.
    /// </summary>
    /// <param name="converter">The JSON converter to add.</param>
    public static void AddConverter(JsonConverter converter)
    {
        DefaultSerializerOptions.Converters.Add(converter);
        // Reset the entire cache as the converter might affect multiple types
        TypeInfoCache.Clear();
    }

    /// <summary>
    /// Registers a JsonTypeInfo generated by an AOT source generator for a specific type.
    /// </summary>
    /// <typeparam name="T">The type for which to register the JsonTypeInfo.</typeparam>
    /// <param name="typeInfo">The JsonTypeInfo to register.</param>
    public static void RegisterAotTypeInfo<T>(JsonTypeInfo<T> typeInfo)
    {
        TypeInfoCache[typeof(T)] = typeInfo;
    }

    /// <summary>
    /// Registers multiple JsonTypeInfo objects generated by AOT source generators.
    /// </summary>
    /// <param name="typeInfos">The JsonTypeInfo objects to register.</param>
    public static void RegisterAotTypeInfos(params JsonTypeInfo[] typeInfos)
    {
        foreach (var typeInfo in typeInfos)
        {
            TypeInfoCache[typeInfo.Type] = typeInfo;
        }
    }

    /// <summary>
    /// Gets the JsonTypeInfo for a type from the cache or creates it if not exists.
    /// </summary>
    /// <typeparam name="T">The type for which to get the JsonTypeInfo.</typeparam>
    /// <returns>The JsonTypeInfo for the specified type.</returns>
    private static JsonTypeInfo<T> GetTypeInfo<T>()
    {
        if (TypeInfoCache.TryGetValue(typeof(T), out var typeInfo))
        {
            return (JsonTypeInfo<T>)typeInfo;
        }

        // If not in cache, use the default resolver
        return (JsonTypeInfo<T>)DefaultSerializerOptions.GetTypeInfo(typeof(T));
    }

    /// <summary>
    /// Deserializes a JSON string to an object of the specified type.
    /// </summary>
    /// <typeparam name="TEntity">The type to deserialize to.</typeparam>
    /// <param name="json">The JSON string to deserialize.</param>
    /// <returns>The deserialized object.</returns>
    public static TEntity Deserialize<TEntity>(string json)
    {
        return Deserialize<TEntity>(json, null);
    }

    public static object Deserialize(string json, Type type, JsonSerializerOptions? options = null)
    {
        if (options == null && TypeInfoCache.TryGetValue(type, out var typeInfo))
        {
            return JsonSerializer.Deserialize(json, typeInfo);
        }

        return JsonSerializer.Deserialize(json, type, options ?? DefaultSerializerOptions);
    }



    /// <summary>
    /// Deserializes a JSON string to an object of the specified type using optional custom serializer options.
    /// </summary>
    /// <typeparam name="TEntity">The type to deserialize to.</typeparam>
    /// <param name="json">The JSON string to deserialize.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>The deserialized object.</returns>
    public static TEntity Deserialize<TEntity>(string json, JsonSerializerOptions? options = null)
    {
        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            return (TEntity)JsonSerializer.Deserialize(json, typeInfo);
        }

        return JsonSerializer.Deserialize<TEntity>(json, options ?? DefaultSerializerOptions);
    }

    /// <summary>
    /// Serializes an object to a JSON string.
    /// </summary>
    /// <typeparam name="TEntity">The type of the object to serialize.</typeparam>
    /// <param name="entity">The object to serialize.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>The serialized JSON string.</returns>
    public static string Serialize<TEntity>(TEntity entity, JsonSerializerOptions? options = null)
    {
        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            return JsonSerializer.Serialize(entity, (JsonTypeInfo<TEntity>)typeInfo);
        }

        return JsonSerializer.Serialize(entity, options ?? DefaultSerializerOptions);
    }

    /// <summary>
    /// Asynchronously deserializes a JSON string to an object of the specified type.
    /// </summary>
    /// <typeparam name="TEntity">The type to deserialize to.</typeparam>
    /// <param name="json">The JSON string to deserialize.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>A task representing the asynchronous operation, with the deserialized object as the result.</returns>
    public static async Task<TEntity> DeserializeAsync<TEntity>(string json, JsonSerializerOptions? options = null)
    {
        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(json));

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            return (TEntity)await JsonSerializer.DeserializeAsync(stream, typeInfo);
        }

        return await JsonSerializer.DeserializeAsync<TEntity>(stream, options ?? DefaultSerializerOptions);
    }

    /// <summary>
    /// Asynchronously serializes an object to a JSON string.
    /// </summary>
    /// <typeparam name="TEntity">The type of the object to serialize.</typeparam>
    /// <param name="entity">The object to serialize.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>A task representing the asynchronous operation, with the serialized JSON string as the result.</returns>
    public static async Task<string> SerializeAsync<TEntity>(TEntity entity, JsonSerializerOptions? options = null)
    {
        using var stream = new MemoryStream();

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            await JsonSerializer.SerializeAsync(stream, entity, (JsonTypeInfo<TEntity>)typeInfo);
        }
        else
        {
            await JsonSerializer.SerializeAsync(stream, entity, options ?? DefaultSerializerOptions);
        }

        return System.Text.Encoding.UTF8.GetString(stream.ToArray());
    }

    /// <summary>
    /// Serializes an object to a JSON file.
    /// </summary>
    /// <typeparam name="TEntity">The type of the object to serialize.</typeparam>
    /// <param name="entity">The object to serialize.</param>
    /// <param name="filePath">The path of the file to write to.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    public static void SerializeToFile<TEntity>(TEntity entity, string filePath, JsonSerializerOptions? options = null)
    {
        using var stream = new FileStream(filePath, FileMode.Create);

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            JsonSerializer.Serialize(stream, entity, (JsonTypeInfo<TEntity>)typeInfo);
        }
        else
        {
            JsonSerializer.Serialize(stream, entity, options ?? DefaultSerializerOptions);
        }
    }

    /// <summary>
    /// Deserializes a JSON file to an object of the specified type.
    /// </summary>
    /// <typeparam name="TEntity">The type to deserialize to.</typeparam>
    /// <param name="filePath">The path of the file to read from.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>The deserialized object.</returns>
    public static TEntity DeserializeFromFile<TEntity>(string filePath, JsonSerializerOptions? options = null)
    {
        using var stream = new FileStream(filePath, FileMode.Open);

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            return (TEntity)JsonSerializer.Deserialize(stream, typeInfo);
        }

        return JsonSerializer.Deserialize<TEntity>(stream, options ?? DefaultSerializerOptions);
    }

    /// <summary>
    /// Asynchronously serializes an object to a JSON file.
    /// </summary>
    /// <typeparam name="TEntity">The type of the object to serialize.</typeparam>
    /// <param name="entity">The object to serialize.</param>
    /// <param name="filePath">The path of the file to write to.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public static async Task SerializeToFileAsync<TEntity>(
        TEntity entity, string filePath, JsonSerializerOptions? options = null
    )
    {
        await using var stream = new FileStream(filePath, FileMode.Create);

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            await JsonSerializer.SerializeAsync(stream, entity, (JsonTypeInfo<TEntity>)typeInfo);
        }
        else
        {
            await JsonSerializer.SerializeAsync(stream, entity, options ?? DefaultSerializerOptions);
        }
    }

    /// <summary>
    /// Asynchronously deserializes a JSON file to an object of the specified type.
    /// </summary>
    /// <typeparam name="TEntity">The type to deserialize to.</typeparam>
    /// <param name="filePath">The path of the file to read from.</param>
    /// <param name="options">Optional custom serializer options. If null, default options are used.</param>
    /// <returns>A task representing the asynchronous operation, with the deserialized object as the result.</returns>
    public static async Task<TEntity> DeserializeFromFileAsync<TEntity>(
        string filePath, JsonSerializerOptions? options = null
    )
    {
        await using var stream = new FileStream(filePath, FileMode.Open);

        if (options == null && TypeInfoCache.TryGetValue(typeof(TEntity), out var typeInfo))
        {
            return (TEntity)await JsonSerializer.DeserializeAsync(stream, typeInfo);
        }

        return await JsonSerializer.DeserializeAsync<TEntity>(stream, options ?? DefaultSerializerOptions);
    }

    /// <summary>
    /// Creates a new instance of an AOT-generated JsonSerializerContext.
    /// </summary>
    /// <typeparam name="TContext">The type of the context to create.</typeparam>
    /// <returns>A new instance of the specified JsonSerializerContext.</returns>
    public static JsonSerializerContext CreateSerializerContext<TContext>()
        where TContext : JsonSerializerContext, new()
    {
        return new TContext();
    }

    /// <summary>
    /// Registers all JsonTypeInfo objects from a JsonSerializerContext in the cache.
    /// </summary>
    /// <param name="context">The JsonSerializerContext containing the type information.</param>
    public static void RegisterSerializerContext(JsonSerializerContext context)
    {
        // JsonSerializerContext doesn't have a GetTypeInfos method.
        // We need to use reflection to get all the properties of type JsonTypeInfo
        var typeInfoProperties = context.GetType()
            .GetProperties()
            .Where(p => p.PropertyType.IsAssignableTo(typeof(JsonTypeInfo)))
            .ToList();

        foreach (var property in typeInfoProperties)
        {
            if (property.GetValue(context) is JsonTypeInfo typeInfo)
            {
                TypeInfoCache[typeInfo.Type] = typeInfo;
            }
        }
    }
}
